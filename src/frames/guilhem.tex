% Slide 2
\begin{frame}{Les premiers algorithmes}
  \begin{itemize}
    \item Calcul de division et de racine carrée dans la civilisation babylonienne (2000--1600 av. n. è.) ;
    \item Crible d’Eratosthène, algorithme d’Euclide dans la Grèce antique (300 av. n. è.) ;
    \item Constructions à la règle et au compas dans la Grèce antique (300 av. n. è.) ;
    \item Résolution des équations du 2nd degrés (Al-Khwarizmi, 820 n.e.) ;
    \item Origine du terme \og algorithme \fg{} à partir de la traduction latine de son nom au 12ème siècle n.e. :
      \emph{Algorithmo de Numero Indorum}.
  \end{itemize}
  \vspace{0.5em}
  Un algorithme formalise une méthode de calcul effective sur des objets mathématiques.
\end{frame}

% Slide 3
\begin{frame}{Méthode effective}
  Une méthode, ou procédure, $M$, est dite \og effective \fg{} (ou \og systématique \fg{} ou \og mécanique \fg{}) lorsque :
  \begin{itemize}
    \item $M$ est définie en termes d’instructions ;
    \item $M$ produira, si elle est exécutée sans erreurs, le résultat souhaité en un nombre fini d’étapes ;
    \item $M$ peut (en pratique ou en principe) être exécutée par un être humain sans l’aide d’aucune machine autre qu’un papier et un crayon ;
    \item $M$ n’exige aucune perspicacité, intuition ou ingéniosité de la part de l’être humain qui applique la méthode.
  \end{itemize}
  \vspace{0.5em}
  {\footnotesize Source : traduction de \texttt{https://plato.stanford.edu/entries/church-turing/}}
\end{frame}

% Slide 4
\begin{frame}{Algorithme}
  Un algorithme est une description finie d’une méthode effective, en termes d’opérations élémentaires bien définies : des instructions.
  \vspace{0.75em}

  On s’attend en général à ce qu’un algorithme soit :
  \begin{itemize}
    \item une procédure déterministe : l’étape suivante est définie de manière unique, s’il y en a une ;
    \item une méthode qui produit toujours un résultat, quelle que soit l’entrée :
      le calcul décrit par un algorithme se termine toujours.
  \end{itemize}
\end{frame}

% Slide 5
\begin{frame}{Algorithme}
  \textbf{Quels objets manipule un algorithme ?}\\
  $\Rightarrow$ Des objets mathématiques : nombres, figures géométriques, expressions algébriques, \dots
  \vspace{1em}

  \textbf{Que calcule un algorithme ?}\\
  $\Rightarrow$ Une fonction mathématique sur ces objets
\end{frame}

% Slide 6
\begin{frame}{Toutes les fonctions mathématiques sont elles calculables par des algorithmes ?}
  Question formulée au début du 20ème siècle par David Hilbert.
  \vspace{0.75em}

  Nécessite de formaliser les notions d’algorithme et de modèle de calcul.
\end{frame}

% Slide 7
\begin{frame}{Une interlude : automatiser le calcul}
  Au 17ème siècle de notre ère, les premiers dispositifs physique permettant d’automatiser le calcul sont inventés :
  \begin{itemize}
    \item La Pascaline (1642), conçue par Blaise Pascal pour effectuer automatiquement des additions et soustractions,
      avec un système de roues dentées.
    \item Son amélioration par Gottfried Wilhelm Leibniz pour réaliser des multiplications et divisions,
  \end{itemize}
  Ce sont les précurseurs des calculatrices mécaniques.
\end{frame}

% Slide 8
\begin{frame}{Programmer ces machines}
  Au 18ème siècle de notre ère, on conçoit la possibilité d’adapter ces machines mécaniques pour réaliser un ensemble varié de taches :
  \begin{itemize}
    \item métier à tisser Jacquard en 1804, utilisant des cartes perforées pour automatiser la fabrication de motifs complexes.
    \item Analytical Engine conçu par Babbage, et dont les premiers programmes sont écrits par Ada Lovelace (1837).
  \end{itemize}
\end{frame}

% Slide 9
\begin{frame}{Analytical Engine}
  \begin{itemize}
    \item Machine mécanique \emph{programmable} conçue par Babbage en 1837 ;
    \item Programmes écrits par Ada Lovelace pour calculer les nombres de Bernoulli :
  \end{itemize}
  \vspace{0.5em}
  \centering
  % À remplacer par le chemin réel de l’image (extraite du PDF page 9)
%  \includegraphics[width=0.9\linewidth]{img/analytical-engine-bernoulli.jpg}
\end{frame}

% Slide 10
\begin{frame}{Modèles de calcul}
  La notion de modèle de calcul émerge dans la première moitié du 20ème siècle, pour formaliser les méthodes effectives réalisable par l’être humain,
  et par les dispositifs mécaniques conçus depuis deux siècles.
  \vspace{0.75em}

  Entre 1930 et 1936 des définitions formelles de modèle de calcul sont fournis :
  \begin{itemize}
    \item Kurt Gödel et Jacques Herbrand introduisent les fonctions $\mu$-récursives.
    \item Alonzo Church introduit le $\lambda$-calcul.
    \item Alan Turing introduit les machines de Turing.
  \end{itemize}
\end{frame}

% Slide 11
\begin{frame}{Thèse de Church-Turing}
  Ces trois modèles définissent la même notion de fonction calculable !
  \vspace{0.75em}

  \textbf{Thèse de Church-Turing :} Chacun de ces modèle peut représenter n’importe quelle méthode effective définie par un algorithme.
  \vspace{0.75em}

  Chacun de ces trois modèles est universel.
\end{frame}

% Slide 12
\begin{frame}{Turing-complétude}
  On dit qu’un modèle de calcul $M$ est Turing-complet si toute méthode effective peut être décrite dans ce modèle.
  \vspace{0.75em}

  La complétude de Turing est généralement prouvée par un encodage d’un modèle de calcul universel standard dans $M$.
  \vspace{0.5em}

  Par exemple en montrant que $M$ peut représenter n’importe quel calcul faisable par une machine de Turing.
\end{frame}

% Slide 13
\begin{frame}{Des fonctions non calculables}
  Ces modèles de calcul permettent d’exhiber des fonctions mathématiques de $\mathbb{N}$ dans Bool qui ne sont pas calculables par un algorithme.
  \vspace{0.75em}

  En effet, chaque algorithme a une description finie, il ne peut donc exister qu’un nombre infini dénombrable de fonctions calculables.
  \vspace{0.5em}

  Or d’après un résultat célèbre de George Cantor, il existe un nombre non dénombrable de fonction de $\mathbb{N}$ dans Bool.
  \vspace{0.75em}

  Le premier exemple concret de telle fonction non calculable est fourni par Alan Turing : le problème de l’arrêt.
  \vspace{0.5em}

  La fonction qui prend en entrée une description d’une machine de Turing et qui renvoie vraie si cette machine s’arrête et faux sinon, n’est pas calculable.
  \vspace{0.5em}

  Pour définir cette fonction, on doit fournir une technique d’encodage d’une machine de Turing sous la forme d’entiers.
\end{frame}

% Slide 14
\begin{frame}{La théorie de la calculabilité}
  Ces premiers travaux vont donner lieu au développement d’une théorie mathématique de ce qui est calculable.
  \vspace{0.75em}

  De nombreux problèmes de décision seront montrés indécidables :
  \begin{itemize}
    \item une formule mathématique est-elle prouvable ?
      \begin{itemize}
        \item[$\Rightarrow$] \og Entscheidungsproblem \fg{} (Problème de la décision), formulé en 1928 par David Hilbert et Wilhelm Ackermann.
        \item[$\Rightarrow$] Prouvé comme étant indécidable en 1936 par Alonzo Church et Alan Turing indépendamment.
      \end{itemize}
    \item une équation diophantienne (un polynôme à coefficients entiers) a-t-elle une solution entière ?
      \begin{itemize}
        \item[$\Rightarrow$] \og 10ème problème de Hilbert \fg{} lors du congrès de mathématique de Paris en 1900.
        \item Prouvé comme étant indécidable en 1970 par Yuri Matiyasevich
          (se basant sur des travaux de Martin Davis, Hilary Putnam and Julia Robinson).
      \end{itemize}
  \end{itemize}
\end{frame}

% Slide 15 (identique dans le PDF)
\begin{frame}{La théorie de la calculabilité}
  Ces premiers travaux vont donner lieu au développement d’une théorie mathématique de ce qui est calculable.
  \vspace{0.75em}

  De nombreux problèmes de décision seront montrés indécidables :
  \begin{itemize}
    \item une formule mathématique est-elle prouvable ?
      \begin{itemize}
        \item[$\Rightarrow$] \og Entscheidungsproblem \fg{} (Problème de la décision), formulé en 1928 par David Hilbert et Wilhelm Ackermann.
        \item[$\Rightarrow$] Prouvé comme étant indécidable en 1936 par Alonzo Church et Alan Turing indépendamment.
      \end{itemize}
    \item une équation diophantienne (un polynôme à coefficients entiers) a-t-elle une solution entière ?
      \begin{itemize}
        \item[$\Rightarrow$] \og 10ème problème de Hilbert \fg{} lors du congrès de mathématique de Paris en 1900.
        \item Prouvé comme étant indécidable en 1970 par Yuri Matiyasevich
          (se basant sur des travaux de Martin Davis, Hilary Putnam and Julia Robinson).
      \end{itemize}
  \end{itemize}
\end{frame}

% Slide 16 (identique dans le PDF)
\begin{frame}{La théorie de la calculabilité}
  Ces premiers travaux vont donner lieu au développement d’une théorie mathématique de ce qui est calculable.
  \vspace{0.75em}

  De nombreux problèmes de décision seront montrés indécidables :
  \begin{itemize}
    \item une formule mathématique est-elle prouvable ?
      \begin{itemize}
        \item[$\Rightarrow$] \og Entscheidungsproblem \fg{} (Problème de la décision), formulé en 1928 par David Hilbert et Wilhelm Ackermann.
        \item[$\Rightarrow$] Prouvé comme étant indécidable en 1936 par Alonzo Church et Alan Turing indépendamment.
      \end{itemize}
    \item une équation diophantienne (un polynôme à coefficients entiers) a-t-elle une solution entière ?
      \begin{itemize}
        \item[$\Rightarrow$] \og 10ème problème de Hilbert \fg{} lors du congrès de mathématique de Paris en 1900.
        \item Prouvé comme étant indécidable en 1970 par Yuri Matiyasevich
          (se basant sur des travaux de Martin Davis, Hilary Putnam and Julia Robinson).
      \end{itemize}
  \end{itemize}
\end{frame}

% Slide 17
\begin{frame}{Une prolifération de modèles de calcul}
  \begin{itemize}
    \item Circuits booléens
    \item Fonctions récursives
    \item Systèmes de réécriture
    \item Machines de Turing
    \item Automates cellulaires
    \item $\lambda$-calcul
    \item Logique des combinateurs
    \item Réseaux de neurones artificiels
    \item Automates à pile
    \item Grammaires formelles
    \item Langage de programmation
  \end{itemize}
  \vspace{0.75em}
  Comment les comparer ?
\end{frame}

% Slide 18
\begin{frame}{Théorie de la complexité}
  La théorie de la complexité étudie les aspects \og pratiques \fg{} de la calculabilité.
  \vspace{0.75em}

  Combien de temps et d’espace mémoire seront nécessaires pour le calcul d’une fonction calculable ?
  \vspace{0.75em}

  Classification des problèmes en fonction de leur utilisation des ressources de temps et d’espace.
  \vspace{0.75em}

  Notion de classe de complexité : LOGSPACE, P, NP, PSPACE, PH, EXPTIME
  \vspace{0.5em}

  Problème complet : NP-complétude
\end{frame}
